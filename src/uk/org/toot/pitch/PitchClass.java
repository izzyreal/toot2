/* Generated by TooT */

/*
To correspond with MIDI:
*     *     *  *     *     *     *  white
C  Db D  Eb E  F  F# G  Ab A  Bb B
0  1  2  3  4  5  6  7  8  9  10 11 pitch class
   *     *        *     *     *		black

copes with enharmonic equivalents

A  B  C  D  E  F  G
9  11 0  2  4  5  7
*/

package uk.org.toot.pitch;

public class PitchClass
{
	// doesn't cope with enharmonic spelling !!! !!!
    private static String[] names = {
        "C", "C#", "D", "Eb", "E", "F", "F#", "G", "G#", "A", "Bb", "B" } ;

    protected PitchClass() {
        // to prevent instantiation
    }

    public static String name(int semi) {
        return names[value(semi)] ;
    }

    public static int value(int semi) {
    	// !!! should cope with -ve
    	return semi % 12;
    }
    
    public static int value(String note) {
        char qual = ' ', letter = Character.toUpperCase(note.charAt(0)) ;
        int base = 0, offset = 0 ;

        switch ( letter ) {
        case 'C': base = 0 ;  break ;
        case 'D': base = 2 ;  break ;
        case 'E': base = 4 ;  break ;
        case 'F': base = 5 ;  break ;
        case 'G': base = 7 ;  break ;
        case 'A': base = 9 ;  break ;
        case 'B': base = 11 ; break ;
        default:
        	throw new IllegalArgumentException(note+" is not a valid pitch class");
        }

        // should cope with double sharp/flat !!!
        if ( note.length() > 1 )
        	qual = note.charAt(1) ;  // specified quality if available

        if ( qual == '#' ) offset++ ;
        else if ( qual == 'b' ) offset-- ;

        return value(base+offset);
    }

    public static boolean isWhite(int val) {
        return !isBlack(val) ;
    }

    public static boolean isBlack(int val) {
        int pc = value(val);
        return ( pc == 1 || pc == 3 || pc == 6 || pc == 8 || pc == 10 ) ;
    }
    
    public static int[] values(String pitches) {
    	String[] notes = pitches.split("\\s+");
    	int[] values = new int[notes.length];
    	int j = 0;
    	for ( int i = 0; i < notes.length; i++) {
    		try {
    			values[j] = value(notes[i]);
    			j += 1;
    		} catch ( Exception e) {
    			// quietly miss out invalid notes
    		}
    	}
		// but have to fill values array to avoid illegal values
    	for ( ; j < values.length; j++ ) {
    		values[j] = values[j-1];
    	}
    	return distinct(values);
    }
    
    public static String names(int[] pitches) {
    	StringBuilder sb = new StringBuilder();
    	for ( int i = 0; i < pitches.length; i++ ) {
    		sb.append(name(pitches[i]));
    		if ( i < pitches.length-1 ) {
    			sb.append(' ');
    		}
    	}
    	return sb.toString();
    }
    
    /**
     * Count the number of pitch classes
     * @param pitches
     * @return
     */
    public static int count(int[] pitches) {
    	int count = 0;
    	int mask = 0;
    	for ( int i = 0; i < pitches.length; i++) {
    		int pc = value(pitches[i]);
    		int bit = 1 << pc;
    		if ( (mask & bit) != 0 ) continue;
    		mask |= bit;
    		count += 1;
    	}
    	return count;
    }
    
    /**
     * Remove duplicate pitch classes
     * @param pitches
     * @return
     */
    public static int[] distinct(int[] pitches) {
    	int count = count(pitches);
    	if ( count == pitches.length ) return pitches; // all distinct
    	int[] distinct = new int[count];
    	count = 0;
    	int mask = 0;
    	for ( int i = 0; i < pitches.length; i++) {
    		int pc = value(pitches[i]);
    		int bit = 1 << pc;
    		if ( (mask & bit) != 0 ) continue;
    		mask |= bit;
    		distinct[count++] = pitches[i];
    	}
    	return distinct;
    }
}
