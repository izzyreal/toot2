/* Generated by TooT */

package uk.org.toot.pitch;

import java.util.Observable;

/**
 * A Key has a root PitchClass and a Scale
 * It does not have a register.
 */
public class Key extends Observable
{
	protected String[] names;
    protected int root;

    /**
     * @link aggregation 
     */
    protected Scale scale;

    /**
     * Constructor
     */
    public Key(int root, Scale scale) {
        this.root = PitchClass.value(root) ;
        this.scale = scale ;
    }

    public Key(String root, Scale scale) {
        this(PitchClass.value(root), scale);
    }

    public Key(int root) {
        this(root, Scales.getInitialScale());
    }

    public Key() {
        this("C", Scales.getInitialScale());
    }

	public boolean contains(int[] notes) {
        // if any note isn't diatonic return false
        for ( int i = 0 ; i < notes.length ; i++ ) {
            if ( !diatonic(PitchClass.value(notes[i])) )
                return false ;
        }
        return true ;
    }

	public boolean contains(String[] notes) {
        // if any note isn't diatonic return false
        for ( int i = 0 ; i < notes.length ; i++ ) {
            if ( !diatonic(PitchClass.value(notes[i])) )
                return false ;
        }
        return true ;
    }

	public boolean diatonic(int semi) {
        return degree(semi) >= 0 ;
    }

    public int degree(int semi) {
        for ( int i = 0 ; i < scale.length() ; i++ ) {
            if ( semi%12 == (root + scale.interval(i))%12 )
                return i ; // diatonic match
        }
        return -1;
    }

    public String[] getNames(){ return names; }

    // allows correction of enharmonic spelling!
    public void setNames(String[] names){ this.names = names; }

    public int getRoot(){ return root; }

    public void setRoot(int root) {
        this.root = PitchClass.value(root);
        setChanged();
        notifyObservers();
//        System.out.println("Key of "+PitchClass.name(root));
    }

    public Scale getScale() { return scale; }

    public void setScale(Scale scale) {
        this.scale = scale;
        setChanged();
        notifyObservers();
    }

    /**
     * Returns the nearest diatonic pitch, preference to lower
     * @param pitch
     * @return
     */
    public int diatonicPitch(int pitch) {
        if ( diatonic(pitch) ) return pitch;
        for ( int disp = 1; disp < 3; disp++ ) {
            if ( diatonic(pitch-disp) ) return pitch-disp;
            if ( diatonic(pitch+disp) ) return pitch+disp;
        }
        return pitch; // oh well, it's still accidental after all!
    }

    public int getNote(int degree) {
    	return getRoot() + getScale().interval(degree);
    }
    
   public int[] getChordNotes(int degree, int poly) {
        int[] notes = new int[poly];
        int[] chordMode = getScale().getChordMode(degree);
        int[] intervals = ChordMode.getIntervals(chordMode, poly, ChordMode.TERTIAN);
        int base = getNote(degree);
        for ( int n = 0; n < poly; n++ ) {
            notes[n] = base + intervals[n];
        }
        return notes;
    }

    public String toString() {
        return name();
    }

    public String name() {
        return name(0)+" "+scale.name() ;
    }

    public String name(int degree) {
        if ( names == null )
            return PitchClass.name(root+scale.interval(degree)) ;

        return names[degree % names.length] ;
    }

    public String toTabbedString() {
        String str = "" ;

        for ( int i = 0, d = 0 ; i < 12 ; i++ )
        {
            if ( d < scale.length() && i == scale.interval(d) )
            {
        		str += name(d)+"\t" ;
                d += 1 ;
            }
            else
                str += "\t" ;
        }

        return str+PitchClass.name(root)+"\t"+scale.name() ;
    }
}
