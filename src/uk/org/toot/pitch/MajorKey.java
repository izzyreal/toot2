/* Generated by TooT */

package uk.org.toot.pitch;

import java.util.Iterator;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/**
 * TODO:
 *  note values for enharmonic search in contains()
 *  more key rings (pentatonic, diminished etc. not just 12)
 * DONE:
 *  n-degrees (not just7)   EXCEPT for toString!
 *  key rings as ArrayLists
 */
public class MajorKey extends Key
{
    /**
     * @label key ring 
     * @supplierCardinality 1..*
     * @link aggregationByValue
     */
    static private List keyring ;

    static { keyring = makeKeys() ; }

    static private String flatten(String note)
    {
        char chars[] = new char[2] ; // space for note and quality chars
        char qual = ' ';             // natural quality default

        chars[0] = note.charAt(0) ;  // letter e.g. 'A' is preserved

        if ( note.length() > 1 )
        	qual = note.charAt(1) ;  // specified quality if available

        if ( qual == '#' ) qual = ' ' ;  // sharp becomes natural
        else if ( qual == ' ' ) qual = 'b' ; // natural becomes flat
        else System.err.println("Can't flatten("+note+")!") ;

        chars[1] = qual ;

        return new String(chars) ; // !!!
    }

    /**
     * Create the Circle of Fifths for all 12 Keys, a doubly linked list.
     * Also links for raise, lower
     * All directional links allow a limited distance to move.
     */
    static private List<Key> makeKeys()
    {
		// start with C..B all sharp (unused key of C#(Db) Major)
        String[] notes = { "C#", "D#", "E#", "F#", "G#", "A#", "B#" } ;

        List<Key> keys = new ArrayList<Key>() ;

        for ( int i = 0 ; i < 12 ; i++ )
        {
            String[] newnotes = new String[notes.length] ;

		//  new root to 4th by offsetting
            for ( int d = 0 ; d < notes.length ; d++ )
            {
            	newnotes[d] = notes[(d+4-1) % notes.length] ;
            }

		//  flatten new 4th by name (#->natural->b, but same letter)
        	newnotes[4-1] = flatten(newnotes[4-1]) ;

		//  new major key of new root
        	int root = PitchClass.value(newnotes[1-1]) ;
        	Key majKey = new Key(root, Scale.Major) ;
            majKey.setNames(newnotes) ;
            keys.add(majKey) ;

            notes = newnotes ; // ready for next key
        }

        for ( int i = 0 ; i < 12 ; i++ )
        {
		//  relate to other Keys: dominant, subdominant, sharpened, flattened
        }

        return keys ;
    }

    static public void printKeys()
    {
        for ( Iterator i = keyring.iterator() ; i.hasNext() ; )
        {
            System.out.println(i.next()) ;
        }

    }

    /**
     * Return the Key as specified (only Major for now!!!)
     */
    static public MajorKey of(String keyname)
    {
        for ( Iterator i = keyring.iterator() ; i.hasNext() ; )
        {
            MajorKey key = (MajorKey)i.next() ;

            if ( keyname.equals(key.name(1-1)) )
                return key ;
        }

        return null ;
    }

    static public List with(String keynotes)
    {
        int nargs ;
        // count arguments
        StringTokenizer st = new StringTokenizer(keynotes) ;
        for ( nargs = 0 ; st.hasMoreTokens() ; )
        {
            st.nextToken() ;
            nargs++ ;
        }

        // allocate space for arguments
        String[] notes = new String[nargs] ;

        // extract each argument
        st = new StringTokenizer(keynotes) ;
		for ( int i = 0 ; i < nargs && st.hasMoreTokens() ; i++ )
        {
            notes[i] = st.nextToken() ;
//            System.out.print(notes[i]+" ") ;
        }
//        System.out.println() ;

        return with(notes) ;
    }

    /**
     * Return a List of Keys with the specified notes
     */
    static public List<Key> with(String[] keynotes)
    {
        List<Key> match = new ArrayList<Key>() ;

//        for ( int i = 0 ; i < keynotes.length ; i++ )
//            System.out.print(keynotes[i]+" ") ;
//        System.out.println() ;

        for ( Iterator i = keyring.iterator() ; i.hasNext() ; )
        {
            Key key = (Key)(i.next()) ;

			if ( key.contains(keynotes) )
                match.add(key) ;
        }

        return match ;
    }
}
