/* Generated by TooT */

package uk.org.toot.midi.sequence;

import java.util.ArrayList;
import java.util.Iterator;
import javax.sound.midi.MidiEvent;
import javax.sound.midi.MidiMessage;
import static uk.org.toot.midi.message.MetaMsg.*;

/** A List of Time Signatures with methods to ease use */
public class TimeSignatureList { //extends ArrayList<MidiEvent> {
    private int resolution;
    private ArrayList < MidiEvent > sigList;
    private ArrayList < Integer > barList;
    private int _bar = 0; // running bar count as events added
    private long _tick = 0; // ditto for tick
    private int _bpb; //
    private int barOffset = 0;

    public TimeSignatureList(int resolution) {
        this.resolution = resolution;
        //        System.out.println("TSL: resolution "+resolution);
        this.sigList = new ArrayList < MidiEvent > ();
        this.barList = new ArrayList < Integer > ();
    }

    public boolean add(MidiEvent event) { // should do remove too!!
        long tick = event.getTick();
        MidiMessage msg = event.getMessage();
        if (getType(msg) != TIME_SIGNATURE)
            throw new IllegalArgumentException("Not a Time Signature!");
        int index = sigList.size();
        sigList.add(event);
        if (tick > _tick) { // not first time
            float beats = (tick / resolution) - (_tick / resolution);
            float bars = beats / _bpb;
            //            System.out.println(bars+" bars ("+beats+" beats at "+_bpb+" beats per bar)");
            _bar += (int)(bars + 0.99f); // round up portions of bars
        }
        barList.add(new Integer(_bar));
        // sort out some stuff for next add
        _tick = tick;
        _bpb = getBeatsPerBar(index);
        //        System.out.println(_tick+"("+_tick/resolution+") : bar "+(1+_bar)+", "+_bpb+" beats/bar");
        return true;
    }

    /** Return the index of the time signature for this tick, or -1 */
    public int getIndex(long tick) {
        int index = -1; // not found
        for (int i = 0; i < sigList.size(); i++) {
            if (getTick(i) > tick) return index; // the previous index
            index = i; // remember previous
        }
        return index;
    }

    /** Return the index of the time signature for this position, or -1 */
    public int getIndex(SequencePosition position) {
        int index = -1; // not found
        for (int i = 0; i < sigList.size(); i++) {
            if (getStartBar(i) > position.bar) return index; // the previous index
            index = i; // remember previous
        }
        return index;
    }

    private void offset(int delta) {
        for (int i = 0; i < barList.size(); i++) {
            int bar = ((Integer)barList.get(i)).intValue();
            bar -= delta;
            barList.set(i, new Integer(bar));
        }
        _bar -= delta;
    }

    public void setBarOffset(int offset) {
        int delta = offset - barOffset;
        offset(delta);
        this.barOffset = offset;
    }

    /** Return a SequencePosition representing the tick */
    public SequencePosition getPosition(long tick) {
        int index = getIndex(tick);
        int bpb = getBeatsPerBar(index);
        int bar0 = getStartBar(index);
        long tick0 = getTick(index);
        long ticks = tick - tick0;
        int beats = (int)(ticks / resolution);
        int bars = beats / bpb;
        beats = beats % bpb;
        bars += bar0;
        ticks %= resolution;
        return new SequencePosition(bars, beats, (int)ticks, resolution);
    }

    /** The inverse of getPosition.  !!! HANDLE Div4 and Div16 !!!!! */
    public long getTick(SequencePosition position) {
        int index = getIndex(position);
        long tick = getTick(index);
        int bpb = getBeatsPerBar(index);
        int bar = position.bar - getStartBar(index);
        return tick + position.getTicksInBeat() + resolution * (position.beat + (bpb * bar));
    }

    public long getTick(int index) {
        if (index < 0) return 0;
        return getEvent(index).getTick();
    }

    /** With this we can linearise each time signature relative to the preceeding integration of bars */
    public int getStartBar(int index) {
        if (index < 0) return 0;
        return ((Integer)barList.get(index)).intValue();
    }

    public int getBeatsPerBar(int index) {
        if (index < 0) return 4;
        MidiMessage msg = (MidiMessage)getEvent(index).getMessage();
        return getData(msg)[0] & 0xFF;
    }

    public int getBeatsPerBar(long tick) {
        return getBeatsPerBar(getIndex(tick));
    }

    public MidiEvent getEvent(int index) {
        return sigList.get(index);
    }

    public Iterator beatIterator(long tick) {
        // do cache research !!
        return new BeatIterator(tick);
    }

    private class BeatIterator implements Iterator {
        protected SequencePosition position;
        private int index; // the index into the time signature list
        private long changeTick; // where the next time signature change is
        private boolean firstTime = true;

        public BeatIterator(long tick) {
            SequencePosition start = getPosition(tick);
            this.position = new SequencePosition(start.bar, start.beat);
            this.index = getIndex(position);
            this.changeTick = getChangeTick();
        }

        public boolean hasNext() {
//            if (getTick(position) + resolution < endTick) return true;
//            return false;
			return true; // time never stops :)
        }

        // take account of beats per bar, index changes!!
        public Object next() {
            if (firstTime) {
                firstTime = false;
            } else {
                position.beat += 1;
            }
            if (position.beat == getBeatsPerBar(index)) {
                position.beat = 0;
                position.bar += 1;
            }
            if (getTick(position) > changeTick) {
                index += 1;
                position.beat = 0;
                position.bar = getStartBar(index);
                changeTick = getChangeTick();
            }
            return position;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        private long getChangeTick() {
            return ((1 + index) >= sigList.size()) ? Long.MAX_VALUE : getTick(1 + index);
        }
    }
}
