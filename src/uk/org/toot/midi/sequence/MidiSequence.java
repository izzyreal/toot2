/* Generated by TooT */

package uk.org.toot.midi.sequence;

import java.util.Iterator;
import java.util.Vector;
import java.util.Calendar;
import javax.sound.midi.Sequence;
import javax.sound.midi.Track;
import javax.sound.midi.MidiEvent;
import javax.sound.midi.MidiMessage;
import uk.org.toot.midi.message.NoteMsg;
import javax.sound.midi.InvalidMidiDataException;
import uk.org.toot.midi.sequence.NameEvent;
import uk.org.toot.misc.ChangeSupport;
import uk.org.toot.misc.UndoableCommand;
import javax.swing.event.ChangeEvent;
import static uk.org.toot.midi.message.MetaMsg.*;

public class MidiSequence extends BasicSequence {
    /**
     * The MidiTracks in this MidiSequence.
     * @see #getTracks
     */
    protected Vector < MidiTrack > midiTracks = new Vector < MidiTrack > ();

    /** @supplierCardinality 1 */
    private TimeSignatureList timeSigs;
    private String name = "<untitled>";
    private MidiEvent tempoEvent;
    private float beatsPerMinute = 120; // default
    private int beatsPerBar = 4; // default
    private int barDivisions = 4; // default
    private ChangeSupport changeSupport;
    private ChangeEvent changeEvent;
    private ChangeSupport structureChangeSupport;
    private int introCount = 0;

    /** @supplierCardinality 1 */
    private SequenceHistory history;

    public MidiSequence(Sequence sequence) throws InvalidMidiDataException {
        super(sequence);
        //        this.name = name;
        setup();
    }

    public MidiSequence(float divisionType, int resolution) throws InvalidMidiDataException {
        super(divisionType, resolution);
        createMasterTrack();
        setup();
        createClickTrack();
    }

    protected void createMasterTrack() {
        try {
            Track track = super.createTrack();
            Calendar now = Calendar.getInstance();
            String title = String.format("%1$ty%1$tm%1$td-%1$tH%1$tM%1$tS", now);
            MidiMessage titlemsg = createMeta(TRACK_NAME, title);
            track.add(new MidiEvent(titlemsg, 0L));
            MidiMessage endmsg = createMeta(MARKER, "End");
            long endTick = resolution * 64; // create some recording space !!!
            track.add(new MidiEvent(endmsg, endTick));
        } catch (InvalidMidiDataException imde) {
            imde.printStackTrace();
        }
    }

/*    public MidiSequence(float divisionType, int resolution, int numTracks)
    	throws InvalidMidiDataException {
        super(divisionType, resolution, numTracks);
        createTrack();
        setup();
    } */

    private void setup() {
        changeSupport = new ChangeSupport(this);
        changeEvent = new ChangeEvent(this); // !!! !!!
        structureChangeSupport = new ChangeSupport(this);
        timeSigs = new TimeSignatureList(getResolution());
        // create a MidiTrack for every Track
        midiTracks.clear();
        for (Track track : getTrackList())
            midiTracks.add(new MidiTrack(track, this));
        parse();
    }

    public MidiTrack getMarkerTrack() {
        for (int i = 0; i < midiTracks.size(); i++) {
            if (midiTracks.get(i).isMarkerTrack())
                return midiTracks.get(i);
        }
        return midiTracks.get(0); // default if no special marker track
    }

    public MidiTrack getTempoTrack() {
        return midiTracks.get(0); // default if no special tempo track
    }

    public Track createTrack() {
        Track track = super.createTrack();
        createMidiTrack(track);
        return track;
    }

    public void addTrack(Track track) {
        super.addTrack(track);
        createMidiTrack(track);
    }

    public void addTrack(MidiTrack midiTrack) {
        super.addTrack(midiTrack.getTrack());
        midiTracks.addElement(midiTrack);
        fireStructureChanged();
        fireChanged();
    }

    protected void createMidiTrack(Track track) {
        midiTracks.addElement(new MidiTrack(track, this));
        parse(); // !!!
        fireStructureChanged();
        fireChanged();
    }

    protected void createClickTrack() {
        try {
            midiTracks.addElement(new ClickTrack(super.createTrack()));
            parse(); // !!!
            fireStructureChanged();
            fireChanged();
        } catch (InvalidMidiDataException imde) {
            imde.printStackTrace();
        }
    }

    public boolean deleteTrack(Track track) {
        synchronized(midiTracks) {
            midiTracks.remove(tracks.indexOf(track));
        }
        boolean ret = super.deleteTrack(track);
        parse(); // !!!
        fireStructureChanged();
        fireChanged();
        return ret;
    }

    // use getTrackCount() rather than .length
    public MidiTrack[] getMidiTracks() {
        return (MidiTrack[]) midiTracks.toArray(new MidiTrack[midiTracks.size()]);
    }

    public MidiTrack getMidiTrack(int trk) {
        return midiTracks.get(trk);
    }

    public int getMidiTrackCount() {
    	return midiTracks.size();
    }
    
    public float getBeatsPerMinute() {
        return beatsPerMinute;
    }

    public void setBeatsPerMinute(float bpm) {
        try {
            MidiMessage msg;
            if (tempoEvent == null) {
                msg = createTempo(bpm);
                tempoEvent = new MidiEvent(msg, 0); // !!! 0 not synced
                getTempoTrack().add(tempoEvent);
            } else {
                msg = setTempo(tempoEvent.getMessage(), bpm);
            }
//            float oldbpm = beatsPerMinute;
            beatsPerMinute = bpm;
            fireChanged();
        } catch (InvalidMidiDataException ex) {
            ex.printStackTrace();
        }
    }

    public int getNominalBeatsPerBar() {
        return beatsPerBar;
    }

    public int getBeatsPerBar(long tick) {
        return timeSigs.getBeatsPerBar(tick);
    }

    public int getBeatCount() {
        return (int)(getTickLength() / getResolution());
    }

    public int getBeat(long tick) {
        return (int)(tick / getResolution());
    }

    public String getName() {
        return name;
    }

    protected void parse() {
        if (midiTracks.size() <= 0) return;
        if (getMarkerTrack() != midiTracks.get(0)) parse(getMarkerTrack());
        parse(midiTracks.get(0));
        //        System.out.println("Parsing Track 0, "+track.size()+" events");
    }

    protected void parse(MidiTrack track) {
        // look at all events
        for (int i = 0; i < track.size(); i++) {
            MidiEvent ev = track.get(i);
            MidiMessage msg = ev.getMessage();
            if ( isMeta(msg) ) {
                switch (getType(msg)) {
                    case TRACK_NAME: // Sequence name
                        this.name = getString(msg);
                        break;
                    case MARKER: // Marker
                        String marker = getString(msg);
                        if ( marker.indexOf("Intro") >= 0 ) {
                        	if ( introCount == 0 ) {
                        		setBarOffset(getPosition(ev.getTick()).bar);
                        	}
                        	introCount += 1;
                        }
                        break;
                    case TEMPO: // Tempo
                        if (tempoEvent != null)
                            break; // only 1st tempo
                        float bpm = getTempo(msg);
                        // truncate it to 2 digits after dot
                        beatsPerMinute = (float)(Math.round(bpm * 100.0f) / 100.0f);
                        //                    System.out.println("Tempo "+bpm+" bpm") ;
                        tempoEvent = ev;
                        break;
                    case SMPTE_OFFSET:
                        break;
                    case TIME_SIGNATURE: // Time Signature
                        beatsPerBar = getData(msg)[0] & 0xFF;
                        barDivisions = (1 << (getData(msg)[1] & 0xFF));
                        timeSigs.add(ev);
                        break;
                    case MAJOR_MINOR_KEY: // Key and major/minor, useless
                        //                	System.out.println("Key Signature") ;
                        break;
                    default: // everything not explicitly cased above
                        //                    System.out.println("Meta "+m.getType()) ;
                        break;
                }
            }
        } // end for
    }

    public void setBarOffset(int offset) {
        timeSigs.setBarOffset(offset);
    }

    public SequencePosition getExtent() {
        return getPosition(getTickLength());
    }

    public SequencePosition getPosition(long tick) {
        return timeSigs.getPosition(tick);
    }

    public long getTick(SequencePosition position) {
        return timeSigs.getTick(position);
    }

    public Iterator beatIterator(long tick) {
        return timeSigs.beatIterator(tick);
    }

    public NameEvent[] getMarkers() {
        Vector < NameEvent > markers = new Vector < NameEvent > ();
        MidiTrack track = getMarkerTrack();
        for (int i = 0; i < track.size(); i++) {
            MidiEvent event = track.get(i);
            MidiMessage msg = event.getMessage();
            if ( isMeta(msg) ) {
                if ( getType(msg) == MARKER )
                    markers.add(new NameEvent(event));
            }
        }
        NameEvent[] array = new NameEvent[markers.size()];
        return (NameEvent[]) markers.toArray(array);
    }

    public ChangeSupport getChangeSupport() {
        return changeSupport;
    }

    public ChangeSupport getStructureChangeSupport() {
    	return structureChangeSupport;
    }
    public void fireChanged() {
        getChangeSupport().fireChange(this.changeEvent);
    }

    protected void fireStructureChanged() {
    	getStructureChangeSupport().fireChange(changeEvent);
    }
    
    public SequenceHistory getHistory() {
        if (history == null)
            history = new SequenceHistory(this);
        return history;
    }

    public void edit(UndoableCommand edit) {
        getHistory().nowdo(edit);
        if ( edit.isStructural() ) {
        	fireStructureChanged();
        }
        fireChanged();
    }

    public class ClickTrack extends MidiTrack {
        private ClickSpec spec = new ClickSpec();

        public ClickTrack(Track track) throws InvalidMidiDataException {
            super(track, MidiSequence.this);
            setDeviceName(spec.device());
            setTrackName("Click");
            // add a listener to the tempo track !!! !!!
            update();
        }

        protected void update() {
            // !!! should this start from zero, what about Intro marker ???
            Iterator beats = beatIterator(0L);
            try {
                while (beats.hasNext()) {
                    SequencePosition pos = (SequencePosition)beats.next();
                    long tick = getTick(pos);
                    if ( tick > getTickLength() ) break;
                    addClick(pos.beat, tick);
                }
            } catch (InvalidMidiDataException imde) {
                imde.printStackTrace();
            }
        }

        protected void addClick(int beat, long tick) throws InvalidMidiDataException {
            // need to know chan, note and vel which depend on beat!
            MidiMessage on = NoteMsg.on(spec.channel(beat), spec.note(beat), spec.velocity(beat));
            add(new MidiEvent(on, tick));
            MidiMessage off = NoteMsg.off(spec.channel(beat), spec.note(beat));
            add(new MidiEvent(off, tick + 2)); // << 1/64th (6 ticks at 96 ppqn)
        }
    }
}
