/* Generated by TooT */

package uk.org.toot.swingui.midiui.sequenceui;

import javax.swing.JComponent;
import javax.swing.Scrollable;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Font;
import java.awt.Point;
import java.util.Iterator;
import uk.org.toot.midi.sequence.MidiTrack;
import uk.org.toot.midi.sequence.SequencePosition;
import uk.org.toot.music.tonality.Pitch;
import javax.sound.midi.MidiEvent;
import javax.sound.midi.MidiMessage;
import uk.org.toot.swingui.midiui.MidiColor;

import static uk.org.toot.midi.message.MetaMsg.*;
import static uk.org.toot.midi.message.NoteMsg.*;

abstract public class SequenceTimeView extends SequenceView
                               implements Scrollable,
                                          MouseMotionListener
{
//    protected MidiSequencer sequencer ;
    protected int maxUnitIncrement = 4; // must figure this out !!
    protected int yCount = 128; // suits midi note and velocity
    protected int pixelsPerY = 8 ;
//    protected float ticksPerPixel ;
    protected TimeHeader timeHeader ;
    protected VelocityHeader velHeader;
//    protected final MidiSequence sequence ;

    protected JPopupMenu popup;
    private PositionCursor positionCursor;

    public SequenceTimeView(Viewer viewer)
    {
        super(viewer, true);
        this.positionCursor = new PositionCursor();
//        this.sequence = viewer.getSequence() ;
//!TPP        ticksPerPixel = sequence.getResolution() / 20 ; // default zoom
        setOpaque(true);
        //Let the user scroll by dragging to outside the window.
        setAutoscrolls(true); //enable synthetic drag events
        addMouseMotionListener(this); //handle mouse drags
//        addMouseListener(new PopupListener(createPopupMenu()));
    }

    public void mouseMoved(MouseEvent e) { }

    public void mouseDragged(MouseEvent e) {
        //The user is dragging us, so scroll!
        Rectangle r = new Rectangle(e.getX(), e.getY(), 1, 1);
        scrollRectToVisible(r);
    }

    public Dimension getPreferredSize() {
        return new Dimension(x(2*getSequence().getTickLength()), yCount*pixelsPerY);
    }

    public Dimension getPreferredScrollableViewportSize() {
        return getPreferredSize();
    }

    public boolean getScrollableTracksViewportWidth() {
        return false;
    }

    public boolean getScrollableTracksViewportHeight() {
        return false;
    }

    public void setMaxUnitIncrement(int pixels) {
        maxUnitIncrement = pixels;
    }

    public int getPixelsPerY(){ return pixelsPerY; }

    public void setPixelsPerY(int pixelsPerY) { this.pixelsPerY = pixelsPerY; }

    public float getTicksPerPixel() {
        return viewer.getTicksPerPixel();
    }

    public void setTicksPerPixel(float ticksPerPixel) {
        viewer.setTicksPerPixel(ticksPerPixel);
//        if ( ticksPerPixel < 1 ) ticksPerPixel = 1;
//        this.ticksPerPixel = ticksPerPixel;
        setSize(getPreferredSize());
        repaint();
    }

    public TimeHeader getTimeHeader() {
        if ( timeHeader == null ) timeHeader = new TimeHeader() ;
        return timeHeader ;
    }

    // default velocity, override for specific y semantics like pitch, drum
    public JComponent getYHeader() {
        if ( velHeader == null ) velHeader = new VelocityHeader();
        return velHeader ;
    }

    boolean painting = false;
    public void repaintPositionCursor(long pos) {
        if ( painting || !isShowing() ) return;
        Graphics g = getGraphics();
        positionCursor.unpaint(g);
        positionCursor.paint(g, pos);
        g.dispose();
    }

    protected void paintMeta(Graphics g, String str, long tick) {
        Rectangle clip = g.getClipBounds() ;

        int x = x(tick) ;
        int y1 = clip.y ;
        int y2 = clip.y + clip.height ;
        g.setColor(metaColor) ;
        g.drawLine(x, y1, x, y2) ;
        g.drawString(str, x+3, !isVelocity() ? y1+10 : y2-3) ;
    }

    /*
     * Overridden by subclasses
     */
    protected void paintNote(Graphics g, int note, int velocity, long onTick, long offTick, boolean bOutline) {
        int x = x(onTick) ;
        int y = y(velocity) ;
        int w = x(offTick-onTick) ;
        if ( w < 3 ) w = 3; // ensure minimum visible width !!! what about match ? !!!
        int h = 3 ; //!!
        g.fillRect(x, y, w, h);
    }

    /*
     * return the midi tick for the screen x coord
     */
    protected long tick(int x) {
        return (long)(x*getTicksPerPixel());
    }

    protected long tick(int x, int y) { return tick(x); }

    /*
     * return the screen x coord for the midi tick
     */
    protected int x(long tick) {
        return (int)(tick/getTicksPerPixel());
    }

    /*
     * return the screen y coord for the midi y value
     * default is to scale to avoid a vertical scrollbar
     * this suits velocity and controllers but not pitch and ridm
     * so override for those views
     */
    protected int y(int ymidi) {
        float y = 127 - ymidi;
		return (int)(y * getHeight() / 128);
    }

    /*
     * return the the midi y value for the screen y coord
     * default is to scale to avoid a vertical scrollbar
     * this suits velocity and controllers but not pitch and ridm
     * so override for those views
     */
    protected int midiy(int y) {
        return (int)(127 - (y * 128 / getHeight()));
    }

    protected int note(int x, int y) { return midiy(y); }

    protected void paintTrack(Graphics g, MidiTrack track) {
        Rectangle drawRect = g.getClipBounds();

        // find the region of ticks
        // choose a range outside the region to ensure proper display
        int offsetTicks = 16 * getSequence().getResolution(); // 2 bars, even at 7/8
        // find the start of the region
        long startTick = tick(drawRect.x) ;
        startTick -= offsetTicks; // before region
        if ( startTick < 0 ) startTick = 0; // clamp
        long endTick = startTick + tick(drawRect.width);
        int hiNote = midiy(drawRect.y);
        int loNote = midiy(drawRect.y+drawRect.height);
//      	if ( trk == 1 )  System.out.println(hiNote+", "+loNote);
        endTick += offsetTicks; // after region

        // calculate the minimum note width
//        int minWidth = 4;
//        if ( minWidth < 4 ) minWidth = 4;

        MidiTrack t = track ;
        int satDiv =  getSelection().getTrack(track).size() > 0 ? 3 : 1;
        float hue = (Float)t.getClientProperty("Hue");
        // for each event in this region
        for ( int i = 0 ; i < t.size() ; i++ )
        {
            MidiEvent event = t.get(i) ;
            if ( event.getTick() < startTick ) continue ; // before tick region
            if ( event.getTick() > endTick ) break ;      // after tick region

           	long onTick = event.getTick() ;
            MidiMessage m = event.getMessage() ;

            if ( isMeta(m) ) {
                switch ( getType(m) ) {
                case MARKER: // marker
                case CUE_POINT: // cue point
                case TIME_SIGNATURE: // time signature
                	paintMeta(g, getString(m), onTick) ;
                }
            } else if ( isNote(m) ) {
    	        if ( isOn(m) ) {
        		    int note = getPitch(m) ;
        			int velocity = getVelocity(m);
                    // !! should check seqRect.y, seqRect.height too !!
                    if ( note > hiNote || note < loNote ) continue;
	            	long offTick = onTick+getSequence().getResolution() ; // !!default if not found
	    	        // always find the real matching off note
	    	        for ( int j = 1+i ; j < t.size() ; j++ ) {
            		 	event = t.get(j) ;
                		if ( event.getTick() > (endTick + offsetTicks) ) break ;
	                	m = event.getMessage() ;
			            if ( !isNote(m) ) continue ;
	    	    	    if ( !isOn(m) && !isOff(m) ) continue ;
            	    	if ( getPitch(m) != note ) continue ;
	            	    offTick = event.getTick() ;
    	            	break ;
	        	    }

    	    		// draw the note
			        g.setColor(MidiColor.asHSB(hue, saturation(velocity)/satDiv, 1.0f));
	    	        paintNote(g, note, velocity, onTick, offTick, false);
    			}
            }
        }
    }

    protected void paintGrid(Graphics g) {
        Rectangle drawRect = g.getClipBounds();
        // find the start of the region
        long startTick = tick(drawRect.x) ;
        long endTick = startTick + tick(drawRect.width);
//        int resolution = sequence.getResolution();
		SequencePosition p ; //= sequence.getPosition(startTick);
        long tick;// = startTick - p.tick; //

        // get position iterator starting before startTick
        Iterator posIter = positionIterator(startTick);
        // iterate positions
        // we only get beat positions, interposlate if necessary
        while ( posIter.hasNext() ) {
            p = (SequencePosition)posIter.next();
        //  draw the position
        	tick = getSequence().getTick(p);
            if ( tick > endTick ) break;
            int x = x(tick);
	        g.setColor((p.beat == 0) ? MidiColor.BAR : MidiColor.BEAT); // bar lines are white
    	    g.drawLine(x, drawRect.y, x, drawRect.y+drawRect.height);
            // if enough space, draw sixteenths
            int t4 = getSequence().getResolution();
            if ( x(t4) > 30 ) {
                g.setColor(MidiColor.SIXTEENTH);
                for ( int i = 1; i < 4; i++ ) {
                    int x2 = x + x((i*t4)/4);
		    	    g.drawLine(x2, drawRect.y, x2, drawRect.y+drawRect.height);
                }
            }
        }
    }

    protected void paintComponent(Graphics g) {
        painting = true; // disable positionCursor timer update
        positionCursor.reset();
		super.paintComponent(g);
        painting = false;
    }

    public Point drawSelectionArea(int x1, int y1, int x2, int y2, Point drag) {
        Graphics g = getGraphics();
        g.setXORMode(Color.black);
        g.setColor(Color.white);
		NormalisedDualPoint norm;
        // first erase old
        norm = new NormalisedDualPoint(x1, y1, drag.x, drag.y);
        g.drawRect(norm.left, norm.top, norm.right-norm.left, norm.bottom-norm.top);
        // then draw new
        drag.x = x2;
        drag.y = y2;
		norm = new NormalisedDualPoint(x1, y1, drag.x, drag.y);
        g.drawRect(norm.left, norm.top, norm.right-norm.left, norm.bottom-norm.top);
        // remember to dispose
        g.dispose();
        return drag;
    }

    // !!! almost generalised for SequenceView +++ !!!

    protected void scrollToVisible(long tick) {
        tick -= getResolution();
        Rectangle visible = getVisibleRect();
        visible.x = (int)(tick/getTicksPerPixel());
    //                System.out.println("Scrolling to "+visible.x+", "+visible.y+"  for bar "+(1+getSequence().getPosition(event.getTick()).bar));
        scrollRectToVisible(visible);
    }

    public int getScrollableUnitIncrement(Rectangle visibleRect,
                                          int orientation,
                                          int direction) {
        //Get the current position.
        int currentPosition = 0;
        int maxInc = this.maxUnitIncrement;
        if (orientation == SwingConstants.HORIZONTAL) {
            currentPosition = visibleRect.x;
            maxInc *= 10;
        } else {
            currentPosition = visibleRect.y;
        }

        //Return the number of pixels between currentPosition
        //and the nearest tick mark in the indicated direction.
        if (direction < 0) {
            int newPosition = currentPosition -
                             (currentPosition / maxInc)
                              * maxInc;
            return (newPosition == 0) ? maxInc : newPosition;
        } else {
            return ((currentPosition / maxInc) + 1)
                   * maxInc
                   - currentPosition;
        }
    }

    public int getScrollableBlockIncrement(Rectangle visibleRect,
                                           int orientation,
                                           int direction) {
        if (orientation == SwingConstants.HORIZONTAL) {
            return visibleRect.width - maxUnitIncrement;
        } else {
            return visibleRect.height - maxUnitIncrement;
        }
    }

    public class TimeHeader extends JComponent
    {
        private int SIZE = 16 ;
        protected int increment;

        public Dimension getPreferredSize() {
                return new Dimension(x(2*getSequence().getTickLength()), SIZE);
        }

        protected void paintComponent(Graphics g) {
            int tickLength;
            String text;
            Rectangle drawRect = g.getClipBounds();
            SequencePosition p;

            // Fill clipping area
            g.setColor(Color.darkGray.brighter());
            g.fillRect(drawRect.x, drawRect.y, drawRect.width, drawRect.height);

            // Do the ruler labels in a small font
            g.setFont(new Font("SansSerif", Font.PLAIN, 10));
            g.setColor(Color.white);

	        // find the start of the region
    	    long startTick = tick(drawRect.x) ;
        	long endTick = startTick + tick(drawRect.width);

	        // get position iterator starting before startTick
    	    Iterator posIter = positionIterator(startTick);
        	// iterate positions
	        while ( posIter.hasNext() ) {
    	        p = (SequencePosition)posIter.next();
        	//  draw the position
        		long tick = getSequence().getTick(p);
                if ( tick > endTick ) break;
	            int x = x(tick);
    	        if (p.beat == 0)  {
        	        tickLength = 4;
            	    text = Integer.toString(1+p.bar);
	            } else {
    	            tickLength = 2;
        	        text = null;
            	}

                // don't pack too close together
                if ( true ) {
            		g.drawLine(1+x, SIZE-1, 1+x, SIZE-tickLength-1);
                	if ( true ) {
		    	        if (text != null)
    			            g.drawString(text, x-2, 8);
	                }
                }
            }
        }
    }

    public class VelocityHeader extends JComponent {
        private int SIZE = 24 ;

        public Dimension getPreferredSize() {
                return new Dimension(SIZE, SequenceTimeView.this.getHeight());
        }

        private int x(int midix) {
            return (SIZE*(127-midix))/128;
        }

        protected void paintComponent(Graphics g) {
    //            Rectangle clip = g.getClipBounds();
            // Fill clipping area
            g.setColor(getBackground());
    //            g.fillRect(clip.x, clip.y, clip.width, clip.height);
            g.fillRect(0, 0, getWidth(), getHeight());

//            int ppp = pixelsPerY ; // for thread safety
            // ticks and labels
            for (int p = 0; p < 128; p+=8) //!!
            {
                int x = x(p);
                int y = y(p);
                g.setColor(getForeground());
                g.drawLine(x,y,SIZE-1,y);
    //            g.setColor(Color.white);
    //            g.fillRect(0, y, SIZE-1, ppp) ;
    //            g.setColor(Color.black);
    //            g.drawRect(0, y, SIZE-1, ppp) ;
    //                g.drawLine(SIZE-1, i, SIZE-tickLength-1);
            }
        }
    }


    protected boolean isVelocity() { return true; }

    public String noteName(int note) {
        return Pitch.name(note);
    }

/*    public PositionCursor getPositionCursor() {
        return positionCursor;
    } */

    /*
     * Inner class for Position Cursor
     */
    private class PositionCursor {

        private int xprev = -1;
        private int y1prev = -1;
        private int y2prev = -1;

        protected void reset() {
            xprev = -1;
        }

        protected void unpaint(Graphics g) {
            if ( xprev < 0 ) return;
            if ( !painting ) {
	            g.setXORMode(Color.black);
    	        g.setColor(Color.white);
   	        	g.drawLine(xprev, y1prev, xprev, y2prev); // draw prev line XOR mode
	            g.setPaintMode();
    	        reset();
            }
        }

        protected void paint(Graphics g, long pos) {
            if ( !painting ) {
	            g.setXORMode(Color.black);
    	        g.setColor(Color.white);
        	    xprev = x(pos) ;
            	y1prev = 0;
	            y2prev = getHeight(); ; //drawHere.y+drawHere.height;
            	g.drawLine(xprev, y1prev, xprev, y2prev); // draw new line XOR mode
    	        g.setPaintMode();
	        }
        }
    }
}
