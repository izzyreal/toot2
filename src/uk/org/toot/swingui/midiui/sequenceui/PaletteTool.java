/* Generated by TooT */

package uk.org.toot.swingui.midiui.sequenceui;

import java.awt.event.MouseEvent;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.Image;
import java.awt.Toolkit;
import java.net.URL;
import java.util.List;
import java.util.ArrayList;
import javax.swing.ImageIcon;
import uk.org.toot.midi.sequence.SequenceHistory;
import uk.org.toot.midi.sequence.edit.Selection;
import uk.org.toot.midi.sequence.edit.TrackSelection;
import uk.org.toot.midi.sequence.MidiTrack;
import uk.org.toot.midi.sequence.MidiNote;
import uk.org.toot.misc.UndoableCommand;

abstract public class PaletteTool { //implements MouseInputListener {
    private String name;
    private ImageIcon icon;
    private Cursor cursor;
    protected Press press;
//    protected Press release;
    protected Point drag;
    protected Selection selection; // the subject of the tool
    private boolean wasDragged;
    protected Editor editor;
    private SequenceHistory history;

    public PaletteTool(String name, String iconName, String cursorName, Point hotPoint, Editor editor) {
        this.name = name;
        this.icon = createIcon(iconName);
        this.cursor = createCursor(cursorName, hotPoint);
        this.editor = editor;
        this.history = editor.getHistory();
    }

    protected ImageIcon getImageIcon(String iconName) {
        ImageIcon icon = null;
   	    String imgLocation = "/toolbarButtonGraphics/tools/" + iconName  + ".gif";
       	URL imageURL = this.getClass().getResource(imgLocation);
        if ( imageURL != null ) {
	        icon = new ImageIcon(imageURL);
		} else {
            System.err.println("Resource not found: "+imgLocation);
        }
        return icon;
    }

	protected ImageIcon createIcon(String iconName) {
        return getImageIcon(iconName);
    }

    protected Cursor createCursor(String cursorName, Point hot) {
        Cursor cursor = Cursor.getDefaultCursor();
        if ( cursorName == null ) return cursor;
        ImageIcon icon = getImageIcon(cursorName);
        if ( icon != null ) {
            Image image = icon.getImage();
            Toolkit toolkit = Toolkit.getDefaultToolkit();
	        cursor = toolkit.createCustomCursor(image, hot, getName());
        }
        return cursor;
    }

    public String getName() {
        return name;
    }

    public ImageIcon getIcon() {
        return icon;
    }

    public Cursor getCursor() {
        return cursor;
    }

    public Selection getSelection() {
        return selection;
    }

    protected MidiTrack track;

    public MidiTrack getTrack() {
        return track;
    }

    // implement MouseInputListener -----------------------------------------------

    public void mouseClicked(MouseEvent e) { }

    public void mouseEntered(MouseEvent e) { }

    public void mouseExited(MouseEvent e) { }

    protected Press createPress(MouseEvent e) {
        return new Press(e);
    }

    // edit and select tools should override createPress and call this !!!

    public void mousePressed(MouseEvent e) {
        press = createPress(e);
        drag = new Point(e.getX(), e.getY());
        wasDragged = false;
        SequenceView view = (SequenceView)e.getSource();
        long tick = press.getTick();
        int value = press.getValue();
        // find which track has been clicked on
   	    track = view.match(tick, value);
        if ( track == null ) return; // exit if nothing clicked on
        MidiNote note = view.match(track, tick, value, false);
        // !! need to decide subject, whether pressed note is selected !!
    	// !! then dragged knows what to drag
        if ( view.getSelection().contains(note) ) {
            selection = /*(SequenceSelection)*/view.getSelection()/*.clone()*/;
      	} else {
            selection = new TrackSelection(track, note);
       	}
//       	System.out.println(selection+", "+selection.size());
	}

    public void mouseReleased(MouseEvent e) { }

    public void mouseDragged(MouseEvent e) {
        wasDragged = true;
    }

    public void mouseMoved(MouseEvent e) { }

    protected boolean wasDragged() { return wasDragged; }

    protected void drawSelectionArea(MouseEvent e) {
        if ( press == null ) return;
        // don't reset press when outside component, may move back
        if ( e.getSource() != press.getSource() ) return;
        SequenceView view = (SequenceView)e.getSource();
        drag = view.drawSelectionArea(press.getX(), press.getY(), e.getX(), e.getY(), drag);
    }

    protected void selectionMoved(MouseEvent e) {
        if ( press == null ) return;
        // don't reset press when outside component, may move back
        if ( e.getSource() != press.getSource() ) return;
        SequenceView view = (SequenceView)e.getSource();
        drag = view.selectionMoved(getSelection(), press.getX(), press.getY(), e.getX(), e.getY(), drag);
    }

    protected void edit(UndoableCommand edit) {
        history.nowdo(edit);
    }

    private static List<MidiNote> emptyNoteList = new ArrayList<MidiNote>();

    protected List<MidiNote> getMatches(MouseEvent e) {
        SequenceView view = (SequenceView)e.getSource();
        MidiTrack track = view.getTopTrack();
        if ( track == null ) return emptyNoteList;
        return view.getMatches(track, press.getX(), press.getY(), e.getX(), e.getY());
    }

    protected int distanceSquared(int x1, int y1, int x2, int y2) {
        int x = x1 - x2;
        int y = y1 - y2;
        return (x*x) + (y*y);
    }

    protected int getNoteValue(SequenceView view, int x, int y) {
        return view.note(x, y);
    }

    protected long ticks(MouseEvent e) {
        SequenceView view = (SequenceView)e.getSource();
        long tick1 = view.tick(press.getX(), press.getY());
        long tick2 = view.tick(e.getX(), e.getY());
        return tick2 - tick1;
    }

    protected int semitones(MouseEvent e) {
        SequenceView view = (SequenceView)e.getSource();
        int note1 = view.note(press.getX(), press.getY());
        int note2 = view.note(e.getX(), e.getY());
        // if the view doesn't represent notes positionally
        // we will return 0 (-1 - -1 = -1 + 1 = 0)
        return note2 - note1;
    }

    // maintains state across mouse listener methods
    protected class Press {
        private Object source;
//        protected MouseEvent mouseEvent;
        protected long tick;
        protected int value;
	    protected MidiNote note = null;
        public int x;
        public int y;
        public Press(MouseEvent e) {
            this.source = e.getSource();
	        SequenceView view = (SequenceView)this.source;
//            this.mouseEvent = e;
            x = e.getX();
            y = e.getY();
            this.tick = view.tick(x, y);
            this.value = getNoteValue(view, x, y);
        }
//        public MouseEvent getMouseEvent() { return mouseEvent; }
        public long getTick() { return tick; }
        public int getValue() { return value; }
        public Object getSource() { return source; }
        public int getX() { return x; }
        public int getY() { return y; }
    }
}
